%Anything that needs to happen before the main loop over our shorter
%averaging periods goes here.

%For the original WADZ data set, preprocessing tasks are gathered into the
%function WADZPreprocessing, which includes:
% - Loading and formatting tilt data
tiltDataLong = WADZPreprocessing();
%Initialise some key parameters for calculating the TKE
TKECalcParams.beamAngle = 25*pi/180; TKECalcParams.anisoParam = 0.1684;
%The maximum number of depth bins should be known ahead of time in order to
%preallocate array sizes for depth-varying data. If the user does not know,
%it is better to err on the side of too many bins than too few, as the
%function call will fail if the preallocated arrays are too small.
maxDepthBins = 91;

%Preallocate the whole-record variables based on the number of bursts being
%analysed
burstStartIndex = 5;
burstEndIndex = 1470;
wholeRecordDatenums = nan((burstEndIndex - burstStartIndex + 1),1);
wholeRecordTKE = nan((burstEndIndex - burstStartIndex + 1),maxDepthBins);

%Burst loop
for burstCtr = burstStartIndex:burstEndIndex
    tic
    %Import a burst into the workspace
    [burstDatenums,burstBeamVelocities] = importWADZBurst(burstCtr,tiltDataLong);

    %Carry out WSST
    %Filter
    %IWSST
    
    %Calculate TKE for unfiltered burst velocities
    wholeRecordTKE(burstCtr - burstStartIndex + 1,:) = calcBurst4BeamTKE(burstBeamVelocities,TKECalcParams);
    
    %CalculateTKE for filtered burst velocities
    
    toc
%End burst loop
end

%Carry out statistical filter
%We assume the wave pseudo-TKE to be a function of depth from surface,
%rather than height above bed. If the EOF is to capture this, we need to
%re-zero the dataset to reflect this, such that each point corresponds to
%the same number of bins below the surface rather than the same number of
%bins above the bed.